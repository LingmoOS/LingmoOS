commit 8d54b428cfe98c21049f94c8af3bf302e44091e9
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Mon Apr 21 19:42:27 2025 +0200

    hurd: Do not restore xstate when it is not initialized
    
    If the process has never used fp before getting a signal, xstate is set
    (and thus the x87 state is not initialized) but xstate->initialized is still
    0, and we should not restore anything.

diff --git a/sysdeps/mach/hurd/i386/sigreturn.c b/sysdeps/mach/hurd/i386/sigreturn.c
index 37fa984070..dc57d6122c 100644
--- a/sysdeps/mach/hurd/i386/sigreturn.c
+++ b/sysdeps/mach/hurd/i386/sigreturn.c
@@ -126,24 +126,27 @@ __sigreturn (struct sigcontext *scp)
     ss->sigaltstack.ss_flags &= ~SS_ONSTACK;
 
 #ifdef i386_XFLOAT_STATE
-  if ((scp->xstate) && (scp->xstate->initialized))
+  if (scp->xstate)
     {
-      unsigned eax, ebx, ecx, edx;
-      __cpuid_count(0xd, 0, eax, ebx, ecx, edx);
-      switch (scp->xstate->fp_save_kind)
-        {
-        case 0: // FNSAVE
-          asm volatile("frstor %0" : : "m" (scp->xstate->hw_state));
-          break;
-        case 1: // FXSAVE
-          asm volatile("fxrstor %0" : : "m" (scp->xstate->hw_state),    \
-                       "a" (eax), "d" (edx));
-          break;
-        default: // XSAVE, XSAVEOPT, XSAVEC, XSAVES
-          asm volatile("xrstor %0" : : "m" (scp->xstate->hw_state),     \
-                       "a" (eax), "d" (edx));
-          break;
-        }
+      if (scp->xstate->initialized)
+	{
+	  unsigned eax, ebx, ecx, edx;
+	  __cpuid_count(0xd, 0, eax, ebx, ecx, edx);
+	  switch (scp->xstate->fp_save_kind)
+	    {
+	    case 0: // FNSAVE
+	      asm volatile("frstor %0" : : "m" (scp->xstate->hw_state));
+	      break;
+	    case 1: // FXSAVE
+	      asm volatile("fxrstor %0" : : "m" (scp->xstate->hw_state),    \
+			   "a" (eax), "d" (edx));
+	      break;
+	    default: // XSAVE, XSAVEOPT, XSAVEC, XSAVES
+	      asm volatile("xrstor %0" : : "m" (scp->xstate->hw_state),     \
+			   "a" (eax), "d" (edx));
+	      break;
+	    }
+	}
     }
   else
 #endif
diff --git a/sysdeps/mach/hurd/x86_64/sigreturn.c b/sysdeps/mach/hurd/x86_64/sigreturn.c
index dff8e76dc8..773c00f86d 100644
--- a/sysdeps/mach/hurd/x86_64/sigreturn.c
+++ b/sysdeps/mach/hurd/x86_64/sigreturn.c
@@ -119,24 +119,27 @@ __sigreturn (struct sigcontext *scp)
     ss->sigaltstack.ss_flags &= ~SS_ONSTACK;
 
 #ifdef i386_XFLOAT_STATE
-  if ((scp->xstate) && (scp->xstate->initialized))
+  if (scp->xstate)
     {
-      unsigned eax, ebx, ecx, edx;
-      __cpuid_count(0xd, 0, eax, ebx, ecx, edx);
-      switch (scp->xstate->fp_save_kind)
-        {
-        case 0: // FNSAVE
-          asm volatile("frstor %0" : : "m" (scp->xstate->hw_state));
-          break;
-        case 1: // FXSAVE
-          asm volatile("fxrstor %0" : : "m" (scp->xstate->hw_state),    \
-                       "a" (eax), "d" (edx));
-          break;
-        default: // XSAVE, XSAVEOPT, XSAVEC, XSAVES
-          asm volatile("xrstor %0" : : "m" (scp->xstate->hw_state),     \
-                       "a" (eax), "d" (edx));
-          break;
-        }
+      if (scp->xstate->initialized)
+	{
+	  unsigned eax, ebx, ecx, edx;
+	  __cpuid_count(0xd, 0, eax, ebx, ecx, edx);
+	  switch (scp->xstate->fp_save_kind)
+	    {
+	    case 0: // FNSAVE
+	      asm volatile("frstor %0" : : "m" (scp->xstate->hw_state));
+	      break;
+	    case 1: // FXSAVE
+	      asm volatile("fxrstor %0" : : "m" (scp->xstate->hw_state),    \
+			   "a" (eax), "d" (edx));
+	      break;
+	    default: // XSAVE, XSAVEOPT, XSAVEC, XSAVES
+	      asm volatile("xrstor %0" : : "m" (scp->xstate->hw_state),     \
+			   "a" (eax), "d" (edx));
+	      break;
+	    }
+	}
     }
   else
 #endif
