.TH "KDK_LOGGER_FLUSH" 3 "Fri Sep 22 2023" "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
kdk_logger_flush \- 在异步写入的方式下，可以调用该函数手动将缓存区中的日志写入文件中  

.SH SYNOPSIS
.br
.PP
\fC#include <libkylog\&.h>\fP
.br

.SS "Functions"
.SS "void kdk_logger_flush ()"

.PP
在异步写入的方式下，可以调用该函数手动将缓存区中的日志写入文件中 
.PP
Link with \fI\-lkylog\fP.
.SH "Detailed Description"
.PP 
接口的主要功能是在异步写入的方式下，可以调用该函数手动将缓存区中的日志写入文件中
.SH EXAMPLES
.EX
#include <libkylog.h>
#include <time.h>
#include <sys/time.h>
#include <signal.h>
#include <assert.h>
#include <sys/wait.h>
#include <unistd.h>
#include <pthread.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

int stop	= 0;
int start	= 0;
pthread_mutex_t	lock;
unsigned int	counts	= 0;

void stopHandler(int sig)
{
	stop	= 1;
}

void startTimer()
{
	alarm(10);
}

void* startlog(void* arg)
{
	while (!start);
	unsigned int count	= 0;
	srand(time(NULL));
	while (!stop)
	{
		int lvl	= rand() % 8;
		switch (lvl)
		{
			case 0 :{ 
				assert(klog_emerg("this is emerg count %d\n" , ++ count) == 0);
				}break;
			case 1 : {
				assert(klog_alert("this is alert count %d\n" , ++ count) == 0);
			}break;
			case 2:{
				assert(klog_crit("this is crit count %d\n" , ++ count) == 0);
			}break;
			case 3:{
				assert(klog_err("this is err count %d\n" , ++ count) == 0);
			}break;
			case 4:{
				assert(klog_warning("this is warning count %d\n" , ++ count) == 0);
			}break;
			case 5:{
				assert(klog_notice("this is notice count %d\n" , ++ count) == 0);
			}break;
			case 6:{
				assert(klog_info("this is info count %d\n" , ++ count) == 0);
			}break;
			case 7:{
				assert(klog_debug("this is debug count %d\n" , ++ count) == 0);
			}break;
		}
	}
	pthread_mutex_lock(&lock);
	counts	+= count;
	pthread_mutex_unlock(&lock);
	printf("共写入%d条日志\n" , count);
	return NULL;
}

int main(int argc , char** argv)
{
	assert(kdk_logger_init("./logtest.conf") == 0);

	// //越界测试
	// char msg[4096];
	// memset(msg , 'F' , sizeof(char) * 4096);
	// klog_debug(msg);

	//压力测试
    signal(SIGALRM, stopHandler);
    pthread_mutex_init(&lock, NULL);
    pthread_t children[7] = {0};
    for (int i = 0; i < 7; i++)
    {
        pthread_create(&children[i], NULL, startlog, NULL);
    }

    start = 1;

    startTimer();
    for (int i = 0; i < 7; i++)
    {
        pthread_join(children[i], NULL);
    }
    kdk_logger_flush();
    pthread_mutex_lock(&lock);
    printf("所有线程写入总量：%u\n", counts);
    pthread_mutex_unlock(&lock);
    return system("cat /var/log/logtest.log | wc -l");
}
.SH "CONFORMING TO"
These functions are as per the withdrawn POSIX.1e draft specification.
The following functions are Linux extensions:
.BR kdk_logger_init (),
.BR kdk_logger_setdir ()
and
.BR kdk_logger_set_autowrap ().
.SH "SEE ALSO"
.BR kdk_logger_init (3),
.BR kdk_logger_setdir (3)
and
.BR kdk_logger_set_autowrap (3).
.SH "Author"
.PP 
Generated automatically by Doxygen for libkylog.h from the source code\&.
